dosseg
.model small
.stack 100h
.data
digit db -10; первое значение массива
.code
.386
	jmp start; переход на начало программы (в противном случае начнёт исполняться код подпрограммы)
positive proc ;подпрограмма для случая отрицательного x
	mov al, 3; 3 в регистр al для того чтобы умножить bl на 3
	mul bl; ax = 3*bl
	add al, 5; так как результат заведомо меньше 256(в ah будет 00), то можно прибавить 5 al, а не к ax 
	mov ah,02h; функция вывода символа на экран
	mov dl,al; выводится символ хранящийся в dl
	push dx; сохраним значение dl в стеке
	shr dl,4 ;сдвигаем на 4 бита регистр dl, теперь содержимое предварюят нули старших 4 битов 
	cmp dl,9; сравниваем с 9
	jg first; если это больше 9, то регистре хранится hex-буква, которую нужно вывести
	add dl,30h; в противном случае добавляем 30h, тем самым получаем аски-значение числа
	int 21h; выводим на экран
	jmp second; с первой цифрой покончено, пееходим ко второй
first:
	add dl,37h; добавляем 37h, тем самым получаем аски-значение hex-буквы
	int 21h; выводим на экран
second:
	pop dx	; восстанавливаем значение dl
	and dl,0fh; обнуляем старшие 4 бита, оставляем значение 4-х младших
	cmp dl,9; сравниваем с 9
	jg third; если это больше 9, то регистре хранится hex-буква, которую нужно вывести
	add dl,30h; в противном случае добавляем 30h, тем самым получаем аски-значение числа
	int 21h; выводим на экран
	jmp fourth; переход на вывод новой строки
third:
	add dl,37h; добавляем 37h, тем самым получаем аски-значение hex-буквы
	int 21h; выводим на экран
fourth:;выводим новую строку
	mov ah, 2
	mov dl, 13
	int 21h
	mov ah, 2
	mov dl, 10
	int 21h
	ret; возвращаемся в точку вызова
endp
negative proc ;подпрограмма для случая отрицательного x
	mov al, bl; скопируем значение bl в al
	imul bl; ax равно bl в квадрате
	add al, 4; так как результат заведомо меньше 256(в ah будет 00), то можно прибавить 4 al, а не к ax
	mov bl, 2; в bl занесём 2 для деления
	div bl; al = ax/ bl
	mov ah,02h; функция вывода символа на экран
	mov dl,al; выводится символ хранящийся в dl
	push dx; сохраним значение dl в стеке
	shr dl,4 ;сдвигаем на 4 бита регистр dl, теперь содержимое предварюят нули старших 4 битов 
	cmp dl,9; сравниваем с 9
	jg first; если это больше 9, то регистре хранится hex-буква, которую нужно вывести
	add dl,30h; в противном случае добавляем 30h, тем самым получаем аски-значение числа
	int 21h; выводим на экран
	jmp second; с первой цифрой покончено, пееходим ко второй
first:
	add dl,37h; добавляем 37h, тем самым получаем аски-значение hex-буквы
	int 21h; выводим на экран
second:
	pop dx	; восстанавливаем значение dl
	and dl,0fh; обнуляем старшие 4 бита, оставляем значение 4-х младших
	cmp dl,9; сравниваем с 9
	jg third; если это больше 9, то регистре хранится hex-буква, которую нужно вывести
	add dl,30h; в противном случае добавляем 30h, тем самым получаем аски-значение числа
	int 21h; выводим на экран
	jmp fourth; переход на вывод новой строки
third:
	add dl,37h; добавляем 37h, тем самым получаем аски-значение hex-буквы
	int 21h; выводим на экран
fourth:;выводим новую строку
	mov ah, 2
	mov dl, 13
	int 21h
	mov ah, 2
	mov dl, 10
	int 21h
	ret; возвращаемся в точку вызова
endp


start:
	mov ax, @data
	mov ds, ax

	mov cx, 21; инициализация счётчика
begin:
	mov bl, digit; перемещаем очередное значение массива в регистр dl
	cmp bl, 0; сравнение с нулём
	jl neg_; если число меньше нуля  перейдём к вызову подпрограммы для случая отрицательного x
	call positive; в противном случае число положительное - вызываем подпрограмму для случая положительного x
	jmp ckl; переход к продолжению тела цикла
neg_:
	call negative; вызов подпограммы для случая отрицательного x
ckl:
	inc digit; увеличиваем число на 1, тем самым получаем следующее значение массива
	dec cx; обработали очередное число - уменьшили значение счётчика на 1
	jnz begin; если счётчик равен нулю, то это значит что мы обработали весь массив, иначе преходим к началу цикла

	mov ah, 4ch
	int 21h
end