#include <stdio.h>
#include <conio.h>
#include <dos.h>
#include <dir.h>
struct ffblk ffblk;
int f_d=0;   // Здесь будем фиксировать прием символа DLE
int j=0;	      // номер передаваемого  символа данных	
int i=0;	      // счетчик принятых символов данных 	
char ctl, in_sv, f1=0, int_save;
void interrupt receiv(void); // Объявление процедуры прерывания
char in_buf[80]={0}; // Буфер ввода
char out_buf[10]={"Hello!"};       // Буфер вывода 
// Определим коды, соответствующие управляющим символам
#define DLE    0x10
#define ENQ    0x05
#define SOH    0x01
#define ETB     0x17
#define ACK0  0x06
#define ACK1  0x08
#define EOT     0x04
#define base  0x3F8  

          /* *** инициализация COM-порта *** */
void init_port()  {
  ctl = inp(base+3);
     outp(base+3, ctl | 0x80); // уст. ст. бит режима
// записываем значение делителя частоты
     outp(base+1, 0x00);
     outp(base+0, 0x0C); // скорость 9600 бод
// устанавливаем характеристики обмена - 8 бит,1 стоп, четность
     outp(base+3, 0x1b); // 0001.1011
// уст. регистр управления прерыванием по вводу
     outp(base+1,  0x01);
// уст. регистр управления modem прерывания */
     outp(base+4,  0x0b);
 }
/* уст. нового обработчика */
 void set_vect()   
 {
  setvect (0x0C, receiv);
 }
 /* *** инициализация контролера прерывания *** */
void init_ctrl()  
{
int_save = inp(0x21);
     outp(0x21,int_save & 0x0E7);
 }
/* *** вывод символа в порт *** */
 void  send_sym (char ch)  
 {
unsigned   out_reg, status_reg;
    status_reg = base+5;
    out_reg = base+0;
        while( (inp(status_reg) & 0x20) == 0);
    outp(out_reg, ch);
 }
/* Обработчик прерывания по вводу символа. В этой процедуре реализован механизм байтстаффинга.*/
void interrupt receiv() {
     char ch;
     unsigned   inp_reg;
     inp_reg = 0x3F8;

     ch=inp(inp_reg);     //пpием символа из порта данных
/* Процедура вывода принятого символа на экран, реализованная с помощью функции BIOS */       
//_AL=ch; _AH=0x0e; _BX=0; geninterrupt(0x10);
/* Учет режима байтстаффинга   */
 if(f_d==0)    /* если флаг  DLE не установлен, т.е. предыдущий  
                         принятый символ был не DLE */
 {      
     if(ch==DLE) f_d=1; // если принят символ DLE установим флаг
     else  in_buf[i++]=ch;  // иначе символ положим в буфер
  }
 else  /* если флаг  DLE  установлен, т.е. предыдущий  */
 {                       /*принятый символ был  DLE */
         if(ch==DLE) // если принят DLE, то это символ данных 
         {  f_d=0; in_buf[i]=ch; i++;}// положим в его в буфер 
         else  /* символ после DLE - управляющий. Код, принятого 
                     управляющего символа заносим в переменную f1
         и сбросим флаг приема DLE */
        {  f_d=0; 
if(ch==ENQ)   f1=ENQ;
             if(ch==SOH) { f1=SOH;  i=0;}
             if(ch==ETB) { f1=ETB; }
             if(ch==ACK0) f1=ACK0;
             if(ch==ACK1) f1=ACK1;
  }   }
   outp (0x20,0x20);
}
void main(void)
{
 char ch;
 clrscr();         // Очистим экран
 init_port();    // Установим параметры COM порта
 set_vect();    //  Заменим вектор прерывания COM порта
init_ctrl();

printf("F1-start, ESC-exit\n");
   for(;;)
    {
       while(!kbhit())
       //если не нажата никакая клавиша пpовеpяем содержимое f1
        {
          // если принят ENQ, отошлем подтверждение ACK0 
          if(f1==ENQ)
                 {f1=0; printf("RECEIVE ENQ\n");
                  send_sym (DLE);send_sym (ACK0); }
         /* если принят ACK0, передадим в линию пакет заголовка 
             с управляющими символами начала и конца заголовка */ 
           if(f1==ACK0)
                 { f1=0;printf("RECEIVE ACK0\n");
                    send_sym(DLE); send_sym(SOH);
                    for(i=0; i<6; i++)
                      {
                        send_sym(out_buf[i]);
                      }
                   send_sym(DLE); send_sym(ETB);
                 }
/* если принят ETB, выведем на экран содержимое входного буфера in_buf и отошлем подтверждение ACK1*/ 
           if(f1==ETB)
                 { f1=0; printf("RECEIVE ETB\n");
                   for(i=0; i<6; i++) putch(in_buf[i]);
                   send_sym(DLE);  send_sym(ACK1);
                 }
            if(f1==ACK1)
                 { f1=0; printf("RECEIVE ACK1\n");}
        }
       //если нажата клавиша
           ch=getch();
            if(ch==27) return;
/* Если нажать F1, то послать символ ENQ - запрос на установление связи */
            if(ch==59)    // Нажата клавиша F1
                 { send_sym (DLE);send_sym (ENQ);}
       }
}
